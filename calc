print("== CALCULADORA CIENTÍFICA ==")
print("== TRABALHO DO LINDO WELLIGTON ==")

PI = 3.14

def seno(g):
    rad = g * PI / 180
    s = 0
    term = rad
    for i in range(1, 10):
        s += term
        term *= -(rad * rad) / ((2 * i) * (2 * i + 1))
    return s

def cos(g):
    rad = g * PI / 180
    c = 1
    term = 1
    for i in range(1, 10):
        term *= -(rad * rad) / ((2 * i - 1) * (2 * i))
        c += term
    return c


def tan(g):
    c = cos(g)
    if abs(c) < 1e-12:
        raise ValueError("Erro na tangente")
    return seno(g) / c


def exp(x):
    soma = 1
    term = 1
    for i in range(1, 20):
        term *= x / i
        soma += term
    return soma

def ln(y):
    if y == 0:
        raise ValueError("ln não funciona em zero")
    x = y - 1
    for _ in range(20):
        x -= (exp(x) - y) / exp(x)
    return x

def log10(x):
    return ln(x) / 2.302585092994

def sqrt(x):
    return x ** 0.5

def reduzir(x):
    return f"{x:.3f}".rstrip("0").rstrip(".")


def parse_complex(s):
    s = s.strip()

    if s.endswith("i"):
        base = s[:-1]
        if base == "" or base == "+":
            return complex(0, 1)
        if base == "-":
            return complex(0, -1)
        return complex(0, float(base))

    return complex(float(s), 0)

def format_complex(c):
    r = reduzir(c.real)
    i = reduzir(c.imag)

    if c.imag == 0:
        return r
    if c.real == 0:
        return i + "i"
    return f"({r} {'+' if c.imag >= 0 else '-'} {i}i)"


class Node:
    def __init__(self, tipo, valor=None, esq=None, dir=None):
        self.tipo = tipo
        self.valor = valor
        self.esq = esq
        self.dir = dir

def tokenize(expr):
    tokens = []
    i = 0

    while i < len(expr):

        if expr[i].isspace():
            i += 1
            continue

        if expr.startswith("**", i):
            tokens.append("**")
            i += 2
            continue
        
        if expr[i] in "+-*/()":
            tokens.append(expr[i])
            i += 1
            continue

        
        for func in ["sen", "cos", "tan", "ln", "log10", "raiz"]:
            if expr.startswith(func, i):
                tokens.append(func)
                i += len(func)
                break
        else:
            
            if expr[i].isdigit() or expr[i] == '.':
                num = ""
                while i < len(expr) and (expr[i].isdigit() or expr[i] == '.'):
                    num += expr[i]
                    i += 1

                if i < len(expr) and expr[i] == "%":
                    tokens.append(str(float(num) / 100))
                    i += 1
                else:
                    tokens.append(num)

                continue

            raise ValueError(f"Invalido: {expr[i]}")

    return tokens


def calccomparse(expr):
    tokens = tokenize(expr)

    def parse_expr():
        node = parse_term()
        while tokens and tokens[0] in ["+", "-"]:
            op = tokens.pop(0)
            node = Node("op", op, node, parse_term())
            return node
        return node

    def parse_term():
        node = parse_power()
        while tokens and tokens[0] in ["*", "/"]:
            op = tokens.pop(0)
            node = Node("op", op, node, parse_power())
        return node

    def parse_power():
        node = parse_factor()
        if tokens and tokens[0] == "**":
            tokens.pop(0)
            node = Node("op", "**", node, parse_power())
        return node

    def parse_factor():
        tok = tokens.pop(0)

        if tok == "(":
            node = parse_expr()
            if not tokens or tokens[0] != ")":
                raise ValueError("Parêntese não fechado.")
            tokens.pop(0)
            return node

        if tok in ["sen", "cos", "tan", "ln", "log10", "raiz"]:
            if tokens.pop(0) != "(":
                raise ValueError("Falta parêntese após função.")
            inside = parse_expr()
            if tokens.pop(0) != ")":
                raise ValueError("Parêntese não fechado após função.")
            return Node("func", tok, inside)

        try:
            val = float(tok)
            return Node("num", complex(val, 0))
        except:
            raise ValueError("Número inválido.")

    return parse_expr()


def evaluate(node):
    if node.tipo == "num":
        return node.valor

    if node.tipo == "func":
        arg = evaluate(node.esq)
        funcoes = {
            "sen": lambda x: seno(x),
            "cos": lambda x: cos(x),
            "tan": lambda x: tan(x),
            "ln": lambda x: ln(x),
            "log10": lambda x: log10(x),
            "raiz": lambda x: sqrt(x),
        }
        return complex(funcoes[node.valor](arg.real), 0)

    esquerda = evaluate(node.esq)
    direita = evaluate(node.dir)

    operacoes = {
        "+": lambda a, b: a + b,
        "-": lambda a, b: a - b,
        "*": lambda a, b: a * b,
        "/": lambda a, b: a / b,
        "**": lambda a, b: a ** b,
    }

    return operacoes[node.valor](esquerda, direita)


def igual(a, b):
    if a.tipo != b.tipo:
        return False
    if a.tipo == "num":
        return a.valor == b.valor
    return (a.valor == b.valor and
            igual(a.esq, b.esq) and
            igual(a.dir, b.dir))


while True:
    print("""
1 - Porcentagem
2 - Expressão aritmética
3 - Verificação de igualdade """)

    op = input("Escolha a opção: ")

    match op:
        case "1":
            entrada = input("Digite o número: ")

            try:
                resultado = float(entrada)
            except:
                print("Erro no numero.")
                continue

            p = float(input("Digite a porcentagem: "))
            print("Resultado:", resultado * (p / 100))

        case "2":
            expr = input("Digite expressão: ")
            try:
                t = calccomparse(expr)
                print("Resultado:", format_complex(evaluate(t)))
            except Exception as e:
                print("Erro:", e)

        case "3":
            try:
                e1 = calccomparse(input("Calc 1: "))
                e2 = calccomparse(input("Calc 2: "))
                print("Iguais" if igual(e1, e2) else "São diferente")
            except Exception as e:
                print("Erro:", e)

        case _:
            print("Opção inválida")
